/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"

using namespace std;

const int octaveForMiddleC = 3;

bool MidiSelectProcessor::findNextNote()
{
    int current = currentNote;
    // User jmin/jmax so this works even if somehow the end user is able to set
    // max below min
    int lower = juce::jmin(lowerNote, upperNote);
    int upper = juce::jmax(lowerNote, upperNote);
    
    while (++current) {
        
        // Loop around if out of range
        if (current > upper || current < lower) {
            current = lower;
        }
        
        // If we get back to where we started without finding availability,
        // give up
        if (current == currentNote) {
            return false;
        }
        
        // Hunt through existing mappings to make sure we don't reuse an existing
        // destination note
        bool found = false;
        for (auto it = transformations.begin(); it != transformations.end(); ++it) {
            if (it->second == current) {
                // No good, we cant't use this
                found = true;
                break;
            }
        }
        
        // If we're not already mapped, then set currentNote and return
        if (!found) {
            currentNote = current;
            return true;
        }
    }
    
    // It will never get here anyway
    return false;
}

//==============================================================================
MidiSelectProcessor::MidiSelectProcessor()
:lowerNote(0), upperNote(127), currentNote(0)
{
}

MidiSelectProcessor::~MidiSelectProcessor()
{
}

//==============================================================================
const juce::String MidiSelectProcessor::getName() const
{
    return JucePlugin_Name;
}

int MidiSelectProcessor::getNumParameters()
{
    return 2;
}

float MidiSelectProcessor::getParameter (int index)
{
    switch (index) {
        case 0:
            return (float)lowerNote / 127.0f;
        
        case 1:
            return (float)upperNote / 127.0f;
            
        default:
            break;
    }
    
    return 0.0f;
}

void MidiSelectProcessor::setParameter (int index, float newValue)
{
    switch (index) {
        case 0:
            lowerNote = (int)(newValue * 127.0f);
            break;
        
        case 1:
            upperNote = (int)(newValue * 127.0f);
            break;
            
        default:
            break;
    }
}

const juce::String MidiSelectProcessor::getParameterName (int index)
{
    switch (index) {
        case 0:
            return juce::translate("Lower Note");
        
        case 1:
            return juce::translate("Upper Note");
            
        default:
            break;
    }
    
    return juce::String();
}

const juce::String MidiSelectProcessor::getParameterText (int index)
{
    switch (index) {
        case 0:
            return juce::MidiMessage::getMidiNoteName(lowerNote, true, true, octaveForMiddleC);
        
        case 1:
            return juce::MidiMessage::getMidiNoteName(upperNote, true, true, octaveForMiddleC);
            
        default:
            break;
    }
    
    return juce::String();
}

const juce::String MidiSelectProcessor::getInputChannelName (int channelIndex) const
{
    return juce::String (channelIndex + 1);
}

const juce::String MidiSelectProcessor::getOutputChannelName (int channelIndex) const
{
    return juce::String (channelIndex + 1);
}

bool MidiSelectProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool MidiSelectProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool MidiSelectProcessor::acceptsMidi() const
{
    return true;
}

bool MidiSelectProcessor::producesMidi() const
{
    return true;
}

bool MidiSelectProcessor::silenceInProducesSilenceOut() const
{
    return true;
}

double MidiSelectProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int MidiSelectProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int MidiSelectProcessor::getCurrentProgram()
{
    return 0;
}

void MidiSelectProcessor::setCurrentProgram (int index)
{
}

const juce::String MidiSelectProcessor::getProgramName (int index)
{
    return juce::String();
}

void MidiSelectProcessor::changeProgramName (int index, const juce::String& newName)
{
}

//==============================================================================
void MidiSelectProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void MidiSelectProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void MidiSelectProcessor::processBlock (juce::AudioSampleBuffer &buffer, juce::MidiBuffer &midiMessages)
{
    // Do nothing to buffer; just let it pass through

    juce::MidiBuffer inputMessages(midiMessages);
    midiMessages.clear();
    
    juce::MidiBuffer::Iterator it(inputMessages);
    while (true) {
        juce::MidiMessage message(0xf0);
        int samplePosition;
        if (!it.getNextEvent(message, samplePosition)) {
            break;
        }
        
        if (message.isNoteOn()) {
            if (findNextNote()) {
            	// We know it's safe to add to the list if findNextNote() returns true
                transformations[message.getNoteNumber()] = currentNote;
                message.setNoteNumber(currentNote);
                midiMessages.addEvent(message, samplePosition);
            }
            else {
                // This will just get skipped, but we must make note of that to also skip
                // the upcomming note off event
                transformations[message.getNoteNumber()] = -1;
            }
        }
        
        else if (message.isNoteOff()) {
            auto transformIt = transformations.find(message.getNoteNumber());
            if (transformIt == transformations.end()) {
                // I have no recollection of this note
                continue;
            }
            
            if (transformIt->second == -1) {
                // We discarded the note on, discard the note off too
                transformations.erase(transformIt);
                continue;
            }
            
            // Okay, make the note off match the note on, then add
            message.setNoteNumber(transformIt->second);
            midiMessages.addEvent(message, samplePosition);
            transformations.erase(transformIt);
        }
        
        else {
            // We don't mess with other events (yet), so pass on through
            midiMessages.addEvent(message, samplePosition);
        }
    }
}

//==============================================================================
bool MidiSelectProcessor::hasEditor() const
{
    return false; // (change this to false if you choose to not supply an editor)
}

juce::AudioProcessorEditor* MidiSelectProcessor::createEditor()
{
    return NULL;
}

//==============================================================================
void MidiSelectProcessor::getStateInformation (juce::MemoryBlock &destData)
{
    // Use json for better forward-compatibility (not just splat)
    
    juce::DynamicObject *data = new juce::DynamicObject;
    data->setProperty("lowerNote", lowerNote);
    data->setProperty("upperNote", upperNote);
    
    juce::String json = juce::JSON::toString(juce::var(data), true);
    
    juce::MemoryOutputStream stream(destData, false);
    stream.write(json.toUTF8(), json.length());
}

void MidiSelectProcessor::setStateInformation (const void *data, int sizeInBytes)
{
    juce::MemoryBlock memoryBlock(data, sizeInBytes);
    juce::MemoryInputStream stream(memoryBlock, false);
    
    juce::String jsonString = stream.readEntireStreamAsString();
    
    auto jsonData = juce::JSON::fromString(jsonString);
    
    // Don't bother trying to read if it's not an object
    if (!jsonData.isObject()) return;
    
    lowerNote = jsonData.getProperty("lowerNote", 0);
    upperNote = jsonData.getProperty("upperNote", 127);
}

//==============================================================================
// This creates new instances of the plugin..
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MidiSelectProcessor();
}
